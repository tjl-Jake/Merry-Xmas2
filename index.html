<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arix Signature Christmas 2025</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; background-color: #050705; overflow: hidden; color: #E0E5D8; }
        #canvas-container { width: 100vw; height: 100vh; }
        .ui-layer { pointer-events: none; position: absolute; inset: 0; z-index: 10; }
        .interactive { pointer-events: auto; }
        /* 极致平滑的淡入效果 */
        #root { animation: fadeIn 2s ease-in; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    </style>
</head>
<body>
    <div id="root">
        <div class="ui-layer flex flex-col justify-between p-10">
            <div>
                <h1 class="text-4xl font-extralight tracking-[0.6em] mb-2">ARIX</h1>
                <div class="h-[1px] w-20 bg-[#F1C40F] opacity-50"></div>
                <p class="text-[10px] tracking-[0.3em] mt-4 opacity-40">SIGNATURE INTERACTIVE / 2025</p>
            </div>
            
            <div class="flex justify-center pb-10">
                <button id="toggleBtn" class="interactive px-10 py-3 border border-[#F1C40F]/30 text-[#F1C40F] rounded-full hover:bg-[#F1C40F]/10 transition-all duration-700 text-[10px] tracking-[0.4em]">
                    EXPLODE EXPERIENCE
                </button>
            </div>
        </div>
        <div id="canvas-container"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>

    <script>
        // --- 核心逻辑：原生 Three.js 保证 100% 兼容性 ---
        let scene, camera, renderer, particles, ornaments;
        let isExploded = false;
        const count = 8000;
        const treePositions = new Float32Array(count * 3);
        const scatterPositions = new Float32Array(count * 3);
        const currentPositions = new Float32Array(count * 3);
        const velocities = new Float32Array(count * 3);

        function init() {
            // 场景初始化
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x050705, 10, 30);
            
            camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 3, 15);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // 生成坐标
            for (let i = 0; i < count; i++) {
                // 树形坐标 (圆锥分布)
                const y = Math.random() * 10;
                const r = ((10 - y) / 10) * 3.5;
                const a = Math.random() * Math.PI * 2;
                const tx = Math.cos(a) * r;
                const ty = y - 5;
                const tz = Math.sin(a) * r;
                treePositions.set([tx, ty, tz], i * 3);
                currentPositions.set([tx, ty, tz], i * 3);

                // 散落坐标 (球形随机)
                const sx = (Math.random() - 0.5) * 25;
                const sy = (Math.random() - 0.5) * 25;
                const sz = (Math.random() - 0.5) * 25;
                scatterPositions.set([sx, sy, sz], i * 3);
            }

            // 粒子系统 (针叶)
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.BufferAttribute(currentPositions, 3));
            const mat = new THREE.PointsMaterial({
                color: 0xA8BBA1,
                size: 0.04,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });
            particles = new THREE.Points(geo, mat);
            scene.add(particles);

            // 装饰物 (实例化小灯点)
            const ornaGeo = new THREE.SphereGeometry(0.1, 8, 8);
            const ornaMat = new THREE.MeshBasicMaterial({ color: 0xF1C40F });
            ornaments = new THREE.Group();
            for(let i=0; i<40; i++) {
                const m = new THREE.Mesh(ornaGeo, ornaMat);
                const idx = Math.floor(Math.random() * count) * 3;
                m.position.set(treePositions[idx], treePositions[idx+1], treePositions[idx+2]);
                ornaments.add(m);
            }
            scene.add(ornaments);

            // 灯光
            const ambient = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambient);
            const point = new THREE.PointLight(0xF1C40F, 2, 50);
            point.position.set(5, 5, 5);
            scene.add(point);

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const pos = particles.geometry.attributes.position;
            const lerpFactor = isExploded ? 0.02 : 0.05;

            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                const tx = isExploded ? scatterPositions[i3] : treePositions[i3];
                const ty = isExploded ? scatterPositions[i3+1] : treePositions[i3+1];
                const tz = isExploded ? scatterPositions[i3+2] : treePositions[i3+2];

                pos.array[i3] += (tx - pos.array[i3]) * lerpFactor;
                pos.array[i3+1] += (ty - pos.array[i3+1]) * lerpFactor;
                pos.array[i3+2] += (tz - pos.array[i3+2]) * lerpFactor;
            }
            pos.needsUpdate = true;

            // 装饰物同步
            ornaments.children.forEach((m, i) => {
                m.position.x += (pos.array[i*100] - m.position.x) * 0.1;
                m.position.y += (pos.array[i*100+1] - m.position.y) * 0.1;
                m.position.z += (pos.array[i*100+2] - m.position.z) * 0.1;
            });

            scene.rotation.y += 0.002;
            renderer.render(scene, camera);
        }

        // 交互逻辑
        document.getElementById('toggleBtn').onclick = function() {
            isExploded = !isExploded;
            this.innerText = isExploded ? "RESTORE HARMONY" : "EXPLODE EXPERIENCE";
        };

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>
